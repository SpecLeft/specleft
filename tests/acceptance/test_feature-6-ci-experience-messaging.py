"""
Acceptance tests for Feature 6: CI Experience & Messaging.

These tests verify that enforcement failures are calm, precise, and actionable
for senior engineers - no marketing language, clear remediation options.

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

from __future__ import annotations

from datetime import date
from pathlib import Path
from unittest.mock import patch

import pytest
import yaml
from click.testing import CliRunner

from specleft import specleft
from specleft.cli.main import cli
from specleft.license.repo_identity import RepoIdentity
from conftest import FeatureFiles
from tests.license.fixtures import (
    TEST_KEY_ID,
    TEST_PUBLIC_KEY_B64,
    add_trusted_key,
    create_core_policy_data,
    create_enforce_policy_data,
    remove_trusted_key,
)

# =============================================================================
# Feature: Feature 6: CI Experience & Messaging
# ID: feature-6-ci-experience-messaging
# priority: medium
# =============================================================================

# Story: Default
# ID: default


@pytest.fixture(autouse=True)
def setup_test_key():
    """Set up test key for each test."""
    add_trusted_key(TEST_KEY_ID, TEST_PUBLIC_KEY_B64)
    yield
    remove_trusted_key(TEST_KEY_ID)


def write_policy_file(
    base_dir: Path, policy_data: dict, filename: str = "policy.yml"
) -> Path:
    """Write a policy file to .specleft/policies directory."""
    licenses_dir = base_dir / ".specleft" / "policies"
    licenses_dir.mkdir(parents=True, exist_ok=True)
    policy_path = licenses_dir / filename

    # Convert dates to strings for YAML
    def convert_dates(obj):
        if isinstance(obj, dict):
            return {k: convert_dates(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [convert_dates(item) for item in obj]
        elif isinstance(obj, date):
            return obj.isoformat()
        return obj

    policy_path.write_text(yaml.dump(convert_dates(policy_data)))
    return policy_path


@specleft(
    feature_id="feature-6-ci-experience-messaging",
    scenario_id="ci-failure-explains-intent-mismatch",
)
def test_ci_failure_explains_intent_mismatch(
    feature_6_ci_failure: tuple[CliRunner, Path, FeatureFiles],
):
    """CI failure explains intent mismatch

    Priority: critical (per PRD)

    Verifies that when enforcement fails in CI, the output message:
    - Explains declared intent (what scenarios were required)
    - Shows current implementation state (what's NOT IMPLEMENTED)
    - Provides clear remediation options (documentation links)
    - Contains NO marketing or pricing language
    """
    runner, _workspace, _files = feature_6_ci_failure

    with specleft.step("Given enforcement fails in CI"):
        # Feature and test files are already created by fixture
        # Create a signed policy requiring critical scenarios
        policy_data = create_enforce_policy_data(
            licensed_to="test-owner/test-repo",
            coverage_threshold=1,
            coverage_fail_below=False,
            priorities={
                "critical": {"must_be_implemented": True},
            },
        )
        write_policy_file(Path("."), policy_data)

    with specleft.step("When output is printed"):
        with patch(
            "specleft.commands.enforce.detect_repo_identity",
            return_value=RepoIdentity(owner="test-owner", name="test-repo"),
        ):
            result = runner.invoke(
                cli,
                ["enforce", ".specleft/policies/policy.yml", "--format", "table"],
            )

        output = result.output

    with specleft.step("Then the message explains:"):
        # Check for declared intent - the output should show what priority was required
        # and which scenarios were violations
        assert (
            "Priority violations" in output or "priority" in output.lower()
        ), f"Expected output to mention priority requirements. Got: {output}"

        # Check that specific scenario is identified as NOT IMPLEMENTED
        assert (
            "NOT IMPLEMENTED" in output or "not implemented" in output.lower()
        ), f"Expected output to show implementation state. Got: {output}"

        # Check that the feature/scenario is identified
        assert (
            "feature-order-processing" in output or "process-critical-order" in output
        ), f"Expected output to identify the violated scenario. Got: {output}"

    with specleft.step("And no marketing or pricing language is included"):
        output_lower = output.lower()

        # Should NOT contain marketing/pricing terms in the violation output
        # Note: pricing links may appear in evaluation warnings, but not in
        # the core violation message
        marketing_terms = [
            "purchase",
            "buy now",
            "subscribe",
            "premium",
            "upgrade today",
            "limited time",
            "discount",
            "special offer",
        ]

        for term in marketing_terms:
            assert term not in output_lower, (
                f"Found marketing language '{term}' in output. "
                f"CI messages should be professional and actionable. Got: {output}"
            )

        # Verify the exit code indicates policy violation (not license issue)
        assert result.exit_code == 1, (
            f"Expected exit code 1 (policy violation) but got {result.exit_code}. "
            f"Output: {output}"
        )


@specleft(
    feature_id="feature-6-ci-experience-messaging",
    scenario_id="documentation-and-support-links-on-ci-failure",
)
@pytest.mark.parametrize(
    "package,policy_filename,policy_creator",
    [
        ("Core+", "policy-core.yml", create_core_policy_data),
        ("Enforce", "policy.yml", create_enforce_policy_data),
    ],
)
def test_documentation_and_support_links_on_ci_failure(
    feature_6_doc_links: tuple[CliRunner, Path, FeatureFiles],
    package: str,
    policy_filename: str,
    policy_creator,
):
    """Documentation and support links on CI failure

    Priority: high

    Verifies that when enforcement fails with policy violations,
    the output includes actionable documentation and support links.
    """
    runner, _workspace, _files = feature_6_doc_links

    with specleft.step(
        f"Given enforcement fails in CI with {package} policy violation"
    ):
        # Feature and test files are already created by fixture
        # Create the appropriate policy type
        policy_data = policy_creator(
            licensed_to="test-owner/test-repo",
            coverage_threshold=1,
            coverage_fail_below=False,
            priorities={
                "critical": {"must_be_implemented": True},
            },
        )
        write_policy_file(Path("."), policy_data, filename=policy_filename)

    with specleft.step(
        f"When output is printed from specleft enforce {policy_filename}"
    ):
        with patch(
            "specleft.commands.enforce.detect_repo_identity",
            return_value=RepoIdentity(owner="test-owner", name="test-repo"),
        ):
            result = runner.invoke(
                cli,
                [
                    "enforce",
                    f".specleft/policies/{policy_filename}",
                    "--format",
                    "table",
                ],
            )

        output = result.output

    with specleft.step('Then the message includes "Documentation: <link>"'):
        assert "Documentation:" in output, (
            f"Expected 'Documentation:' link in output for {package} policy. "
            f"Got: {output}"
        )

        # Verify the documentation link is a valid URL
        assert (
            "https://" in output
        ), f"Expected documentation link to be a valid URL. Got: {output}"

    with specleft.step('And the message includes "Support: <link>"'):
        assert "Support:" in output, (
            f"Expected 'Support:' link in output for {package} policy. "
            f"Got: {output}"
        )

    with specleft.step("And both links are actionable and relevant"):
        # Verify links point to specleft.dev domain (actionable and relevant)
        assert (
            "specleft.dev" in output
        ), f"Expected links to point to specleft.dev. Got: {output}"

        # Verify the enforcement failed (so we're testing failure path)
        assert result.exit_code == 1, (
            f"Expected exit code 1 (policy violation) but got {result.exit_code}. "
            f"Output: {output}"
        )

        # Verify that documentation link appears to be for enforcement docs
        assert (
            "docs" in output.lower() or "enforce" in output.lower()
        ), f"Expected documentation to be relevant to enforcement. Got: {output}"
