"""
Acceptance tests for Feature 2: Specification Format.

These tests verify the canonical feature file format is accepted by SpecLeft,
including minimal valid files and files with optional metadata.

Generated by SpecLeft - https://github.com/SpecLeft/specleft
"""

from __future__ import annotations

import json
from pathlib import Path

from click.testing import CliRunner

from specleft import specleft
from specleft.cli.main import cli
from conftest import FeatureFiles

# =============================================================================
# Feature: Feature 2: Specification Format
# ID: feature-2-specification-format
# priority: critical
# =============================================================================

# Story: Default
# ID: default


@specleft(
    feature_id="feature-2-specification-format",
    scenario_id="minimal-valid-feature-file",
)
def test_minimal_valid_feature_file(
    feature_2_minimal: tuple[CliRunner, Path, FeatureFiles],
) -> None:
    """Minimal valid feature file

    Priority: critical

    Verifies that a feature file with only the minimum required elements
    (at least one scenario with a priority) is considered valid by SpecLeft.
    """
    runner, _workspace, _files = feature_2_minimal

    with specleft.step("Given a feature file exists under .specleft/specs/"):
        # Feature file is already created by fixture
        pass

    with specleft.step("When it contains at least one scenario with a priority"):
        # The feature file above contains exactly one scenario with priority: high
        result = runner.invoke(cli, ["features", "validate", "--format", "json"])

    with specleft.step("Then it is considered valid by SpecLeft"):
        assert result.exit_code == 0, f"Validation failed: {result.output}"
        payload = json.loads(result.output)
        assert payload["valid"] is True, f"Expected valid=True, got: {payload}"
        assert payload["scenarios"] >= 1, "Expected at least 1 scenario"

    with specleft.step("And missing metadata fields are treated as null"):
        # List features with JSON to inspect metadata fields
        list_result = runner.invoke(cli, ["features", "list", "--format", "json"])
        assert list_result.exit_code == 0, f"List failed: {list_result.output}"

        list_payload = json.loads(list_result.output)
        assert "features" in list_payload, "Expected 'features' key in output"
        assert len(list_payload["features"]) >= 1, "Expected at least 1 feature"

        feature = list_payload["features"][0]
        # Optional fields should be null/None when not specified
        # These include: confidence, assumptions, open_questions, owner, component
        optional_fields = [
            "confidence",
            "assumptions",
            "open_questions",
            "owner",
            "component",
        ]
        for field in optional_fields:
            # Field should exist and be null (not cause KeyError)
            assert (
                field in feature
            ), f"Optional field '{field}' should be present in output"
            # Value should be None/null (not an error or missing)
            assert (
                feature[field] is None
            ), f"Optional field '{field}' should be null when not specified, got: {feature[field]}"


@specleft(
    feature_id="feature-2-specification-format",
    scenario_id="optional-metadata-does-not-block-usage",
)
def test_optional_metadata_does_not_block_usage(
    feature_2_metadata_variants: tuple[CliRunner, Path, FeatureFiles, FeatureFiles],
) -> None:
    """Optional metadata does not block usage

    Priority: high

    Verifies that:
    1. Including optional metadata in a feature file does not cause parsing errors
    2. Metadata fields are present in JSON output (as null when not parseable)
    3. Absence of metadata does not cause errors

    Note: YAML frontmatter parsing at the start of files is currently limited.
    This test validates that the system gracefully handles metadata presence/absence.
    """
    runner, _workspace, _with_meta_files, _without_meta_files = (
        feature_2_metadata_variants
    )

    with specleft.step("Given a feature file includes optional metadata"):
        # Feature files are already created by fixture
        pass

    with specleft.step("When SpecLeft parses the file"):
        # Validate both files - should not error regardless of metadata
        validate_result = runner.invoke(
            cli, ["features", "validate", "--format", "json"]
        )
        assert (
            validate_result.exit_code == 0
        ), f"Validation failed: {validate_result.output}"

        # List features with JSON output
        list_result = runner.invoke(cli, ["features", "list", "--format", "json"])
        assert list_result.exit_code == 0, f"List failed: {list_result.output}"

    with specleft.step("Then metadata is included in JSON output"):
        list_payload = json.loads(list_result.output)
        features = list_payload["features"]

        # Both features should be parsed successfully
        assert len(features) == 2, f"Expected 2 features, got {len(features)}"

        # Find the feature with metadata by title
        feature_with_meta = None
        for f in features:
            if "with metadata" in f["title"].lower():
                feature_with_meta = f
                break

        assert (
            feature_with_meta is not None
        ), f"Could not find feature with metadata. Features: {[f['title'] for f in features]}"

        # Verify the feature was parsed (has required fields)
        assert "feature_id" in feature_with_meta, "Expected feature_id"
        assert "title" in feature_with_meta, "Expected title"
        assert "scenarios" in feature_with_meta, "Expected scenarios"
        assert len(feature_with_meta["scenarios"]) >= 1, "Expected at least 1 scenario"

        # Metadata fields should exist in output (even if null due to parsing limitations)
        metadata_fields = [
            "confidence",
            "owner",
            "component",
            "tags",
            "assumptions",
        ]
        for field in metadata_fields:
            assert (
                field in feature_with_meta
            ), f"Metadata field '{field}' should be present in JSON output"

    with specleft.step("And absence of metadata does not cause errors"):
        # Find the feature WITHOUT metadata
        feature_without_meta = None
        for f in features:
            if "without" in f["title"].lower():
                feature_without_meta = f
                break

        assert (
            feature_without_meta is not None
        ), f"Could not find feature without metadata. Features: {[f['title'] for f in features]}"

        # Verify it was parsed successfully (has required fields)
        assert "feature_id" in feature_without_meta, "Expected feature_id"
        assert "title" in feature_without_meta, "Expected title"
        assert "scenarios" in feature_without_meta, "Expected scenarios"
        assert (
            len(feature_without_meta["scenarios"]) >= 1
        ), "Expected at least 1 scenario"

        # Optional fields should be null but present (no KeyError)
        assert (
            feature_without_meta.get("confidence") is None
        ), "Expected confidence=null for minimal feature"
        assert (
            feature_without_meta.get("owner") is None
        ), "Expected owner=null for minimal feature"

        # Overall validation should have passed for both features
        validate_payload = json.loads(validate_result.output)
        assert validate_payload["valid"] is True, "Both features should be valid"
        assert (
            validate_payload["features"] == 2
        ), f"Expected 2 features, got: {validate_payload['features']}"
        assert (
            len(validate_payload.get("errors", [])) == 0
        ), f"Expected no errors, got: {validate_payload.get('errors')}"
